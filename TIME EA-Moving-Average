#property copyright "Copyright 2023, MetaQuotes Ltd."
#property link "https://www.mql5.com"
#property version "1.00"

//+------------------------------------------------------------------+
//| include Expert initialization function                                   |
//+-----------------------------------------------------------
#include <Trade\Trade.mqh>

//---------------------------------------------------------------------+
//|  INPUT GLOBAL VARIABLE                                             |
//+--------------------------------------------------------------------+
     struct RANGE_STRUCT {
     
    datetime  start_time; //start of range
    datetime  end_time;   //end of range
    datetime  close_time; //close of range
    double  high;         //high of range
    double low;           //low of range
    bool f_entry;          //flag if we are inside the range
    bool f_high_breakout; //flag if a high breakout occurance
    bool f_low_breakout;  //flag if a low breakout occurance
    
   RANGE_STRUCT() :start_time(0),end_time(0),close_time(0),high(0),low(99999),f_entry(false),f_high_breakout(false),f_low_breakout(false) {};  
   };
   
   RANGE_STRUCT range;
   MqlTick prevTick,lastTick;
   CTrade trade;
//+------------------------------------------------------------------+
//| INPUT |
//+------------------------------------------------------------------+

input int InpRangeStart = 600; //range start time is minutes after mid -night
input int InpRangeDuration = 120; // range duration in minutes
input int InpRangeClose = 1200; //range close time in minutes
input double InpLots = 0.01; // lot side
input long InpMageicNumber = 12345; // magic number

//+------------------------------------------------------------------+
//| Expert initialization function |
//+------------------------------------------------------------------+
int OnInit(){

if(InpMageicNumber <= 0){
Alert("MageicNumber <= 0");
return INIT_PARAMETERS_INCORRECT;
}
if(InpLots <= 0 || InpLots > 1){
Alert("lots <= 0 or > 1");
return INIT_PARAMETERS_INCORRECT;
}
if(InpRangeStart <= 0 || InpLots >= 1440){
Alert(" Range start < 0 or >= 1440");
return INIT_PARAMETERS_INCORRECT;
}

if(InpRangeDuration <= 0 || InpRangeDuration >= 1440){
 Alert(" Range start < 0 or >= 1440");
 return INIT_PARAMETERS_INCORRECT;
}

if(InpRangeClose <= 0 || InpRangeClose >= 1440 || (InpRangeStart+InpRangeDuration)%1440 == InpRangeClose){
 Alert("Close time < 0 or >= 1440 or end time == close time");
 return INIT_PARAMETERS_INCORRECT;
}

return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{

}

//+------------------------------------------------------------------+
//| Expert tick function |
//+------------------------------------------------------------------+
void OnTick(){
    
   // Get current tick
   prevTick = lastTick;
   SymbolInfoTick(_Symbol,lastTick);
   
   // calculate new range if .....
  if ((InpRangeClose >=0 && lastTick.time>=range.close_time)                     // close time reached
    ||(range.f_high_breakout && range.f_low_breakout)                          //both breakout flags are true
    || (range.end_time  ==0)                                                     //range not calculated yet
    || (range.end_time !=0 && lastTick.time>range.end_time && !range.f_entry)){   //there was a range calculated but no tick inside
    //CountOpenPosition()==0 ){
    
    calculateRange();
    
    }
}
// calculate new range
 void calculateRange () {
 
   // reset range variables
   range.start_time = 0;
   range.end_time = 0;
   range.close_time = 0;
   range.high = 0.0;
   range.f_entry = false;
   range.f_high_breakout = false;
   range.f_low_breakout = false;
   
   // calculate range start time
   int time_cycle = 86400;
   range.start_time = (lastTick.time - (lastTick.time % time_cycle)) + InpRangeStart*60;
   for (int i=0; i<0; i++){
        MqlDateTime tap;
        TimeToStruct(range.start_time,tap);
        int dow = tap.day_of_week;
        if(lastTick.time >= range.start_time || dow==6 || dow==0) {
          range.start_time += time_cycle;
          
      }
    }
    
   // calculate Range end time_cycle
    range.end_time = range_start_time + InpRangeDuration*60;
    for(int i=0; i<2; i++){
       MqlDateTime tmp;
       TimeToStruct(range.end_time,tmp);
       int dow = tmp.day of_week;
       if(range.close_time <= range.end_time || dow==6 || dow==0) {
          range.close_time += time_cycle;
       }
    }
 }
