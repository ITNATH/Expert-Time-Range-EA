#property copyright "Copyright 2023, MetaQuotes Ltd."
#property link "https://www.mql5.com"
#property version "1.00"

//+------------------------------------------------------------------+
//| include Expert initialization function                                   |
//+-----------------------------------------------------------
    #include <Trade\Trade.mqh>

//---------------------------------------------------------------------+
//|  INPUT GLOBAL VARIABLE                                             |
//+--------------------------------------------------------------------+
     struct RANGE_STRUCT {
     
    datetime  start_time; //start of range
    datetime  end_time;   //end of range
    datetime  close_time; //close of range
    double  high;         //high of range
    double low;           //low of range
    bool f_entry;          //flag if we are inside the range
    bool f_high_breakout; //flag if a high breakout occurance
    bool f_low_breakout;  //flag if a low breakout occurance
    
   RANGE_STRUCT() :start_time(0),end_time(0),close_time(0),high(0),low(99999),f_entry(false),f_high_breakout(false),f_low_breakout(false) {};  
   };
   
   RANGE_STRUCT range;
   MqlTick prevTick,lastTick;
   CTrade trade;
//+------------------------------------------------------------------+
//| INPUT |
//+------------------------------------------------------------------+

input int InpRangeStart = 600; //range start time is minutes after mid -night
input int InpRangeDuration = 120; // range duration in minutes
input int InpRangeClose = 1200; //range close time in minutes
input double InpLots = 0.01; // lot side
input long InpMageicNumber = 12345; // magic number

//+------------------------------------------------------------------+
//| Expert initialization function |
//+------------------------------------------------------------------+
int OnInit(){

if(InpMageicNumber <= 0){
Alert("MageicNumber <= 0");
return INIT_PARAMETERS_INCORRECT;
}
if(InpLots <= 0 || InpLots > 1){
Alert("lots <= 0 or > 1");
return INIT_PARAMETERS_INCORRECT;
}
if(InpRangeStart <= 0 || InpLots >= 1440){
Alert(" Range start < 0 or >= 1440");
return INIT_PARAMETERS_INCORRECT;
}

if(InpRangeDuration <= 0 || InpRangeDuration >= 1440){
 Alert(" Range start < 0 or >= 1440");
 return INIT_PARAMETERS_INCORRECT;
}

if(InpRangeClose <= 0 || InpRangeClose >= 1440 || (InpRangeStart+InpRangeDuration)%1440 == InpRangeClose){
 Alert("Close time < 0 or >= 1440 or end time == close time");
 return INIT_PARAMETERS_INCORRECT;
}

// set maginumber
trade.SetExpertMagicNumber(InpMageicNumber);

 //calculated new range if input changed
if(_UninitReason==REASON_PARAMETERS){     // so position open +++++

 calculateRange();

}

return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{

  // delete objects
  ObjectsDeleteAll(NULL,"range");
  

}

//+------------------------------------------------------------------+
//| Expert tick function |
//+------------------------------------------------------------------+
void OnTick(){
    
   // Get current tick
   prevTick = lastTick;
   SymbolInfoTick(_Symbol,lastTick);
   
   //RANGE CALCYLATION
   
   if(lastTick.time >= range.start_time && lastTick.time< range.end_time){
   
         // set flag
      
      range.f_entry = true;
      
         //new high
         
      if (lastTick.ask > range.high){
         range.high = lastTick.ask;
         DrawObjects();
      
      }
         // new low
         
     if (lastTick.bid < range.low){
         range.low = lastTick.bid;
         DrawObjects();
         
     }
     
   }
   
   // CLOSE POSITION
   
   if(lastTick.time >= range.close_time){
      if(!ClosePositions()){return;}
   
   }
   
  
   
   // calculate new range if .....
  if (((InpRangeClose >=0 && lastTick.time>=range.close_time)                     // close time reached
    ||(range.f_high_breakout && range.f_low_breakout)                          //both breakout flags are true
    || (range.end_time  ==0)                                                     //range not calculated yet
    || (range.end_time !=0 && lastTick.time>range.end_time && !range.f_entry))   //there was a range calculated but no tick inside
    && CountOpenPositions()==0 ){
    
    calculateRange();
    
    }
    
    // check for breakouts
    CheckBreakouts();
    
    
    
}
// calculate new range
 void calculateRange () {
 
   // reset range variables
   range.start_time = 0;
   range.end_time = 0;
   range.close_time = 0;
   range.high = 0.0;
   range.f_entry = false;
   range.f_high_breakout = false;
   range.f_low_breakout = false;
   
   // calculate range start time
   int time_cycle = 86400;
   range.start_time = (lastTick.time - (lastTick.time % time_cycle)) + InpRangeStart*60;
   for (int i=0; i<0; i++){
        MqlDateTime tap;
        TimeToStruct(range.start_time,tap);
        int dow = tap.day_of_week;
        if(lastTick.time >= range.start_time || dow==6 || dow==0) {
          range.start_time += time_cycle;
          
      }
    }
    
   // calculate Range end time_cycle
    range.end_time = range.start_time + InpRangeDuration*60;
    for(int i=0; i<2; i++){
       MqlDateTime tmp;
       TimeToStruct(range.end_time,tmp);
       int dow = tmp.day_of_week;
       if(dow==6 || dow==0) {
          range.end_time += time_cycle;
       }
    }
    
       // calculate Range Close
    range.close_time = (range.end_time - (range.end_time % time_cycle)) + InpRangeClose*60;
    for(int i=0; i<2; i++){
       MqlDateTime tmp;
       TimeToStruct(range.close_time,tmp);
       int dow = tmp.day_of_week;
       if(range.close_time <= range.end_time || dow==6 || dow==0) {
          range.close_time += time_cycle;
       }
    }
    
      //DRAW OBJECTS
      DrawObjects();
 }
    int CountOpenPositions(){
     
      int counter = 0;
      int total = PositionsTotal();
      for(int i=total-1; i>=0; i--) {
          ulong ticket = PositionGetTicket(i);
          if(ticket <=0){Print("Failed to get position ticket"); return -1;}
          if(!PositionSelectByTicket(ticket)){Print("failed to select postion by ticket"); return -1;}
          ulong magicnumber;
          if(!PositionGetInteger(POSITION_MAGIC,magicnumber)){Print("failed to get postion by magicnumber"); return -1;}
          if( InpMageicNumber == magicnumber){ counter++;}
          
    }
    
    return counter;
  }
  
  
  
  void CheckBreakouts(){
  
  // CHECK IF WE ARE AFTER THE RANGE END
  
  if(lastTick.time >= range.end_time && range.end_time >0 && range.f_entry){
  
  
  // check for high breakout
  
  if (!range.f_high_breakout && lastTick.ask >= range.high){
      range.f_high_breakout = true;
  
  // open buy position
  
  trade.PositionOpen(_Symbol,ORDER_TYPE_BUY,InpLots,lastTick.ask,0,0,"Time range EA");
  
        }
            
   // check for low breakout
  
  if (!range.f_low_breakout && lastTick.bid <= range.low){
      range.f_low_breakout = true;
  
  // open sell position
  
  trade.PositionOpen(_Symbol,ORDER_TYPE_SELL,InpLots,lastTick.bid,0,0,"Time range EA");
 
           }
  
       }

  }
  
  bool ClosePositions(){
  
  
  int total = PositionsTotal ();
  for(int i=total-1; i>=0; i--) {
      if(total!= PositionsTotal ()){total=PositionsTotal(); i=total; continue;}
      ulong ticket = PositionGetTicket(i);     //select positions
      if(ticket <=0){Print("Failed to get position ticket"); return false;}
      if(!PositionSelectByTicket(ticket)){Print("failed to select postion by ticket"); return false;} 
      long magicnumber;
      if(!PositionGetInteger(POSITION_MAGIC,magicnumber)){Print("failed to select postion by ticket"); return false;}
      if(magicnumber == InpMageicNumber){
      trade.PositionClose(ticket);
      if(trade.ResultRetcode()!=TRADE_RETCODE_DONE){
          Print("Failed to closed position. Result: "+(string)trade.ResultRetcode()+":"+trade.ResultRetcodeDescription());
          return false;
        }
     }

}  
  
     
    return true;
    
       
  
    }
  
  
  

 void DrawObjects(){

  // start 
   ObjectDelete(NULL,"range start");
   if(range.start_time>0){
     ObjectCreate(NULL,"RANGE START",OBJ_VLINE,0,range.start_time,0);
     ObjectSetString(NULL, "range start",OBJPROP_TOOLTIP,"start of the range \n"+TimeToString(range.start_time,TIME_DATE|TIME_MINUTES));
     ObjectSetInteger(NULL,"range start",OBJPROP_COLOR,clrBlue);
     ObjectSetInteger(NULL,"range start",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range start",OBJPROP_BACK,true);
     
       }
       
     //end time
     
     ObjectDelete(NULL,"range end");
   if(range.end_time>0){
     ObjectCreate(NULL,"RANGE end",OBJ_VLINE,0,range.end_time,0);
     ObjectSetString(NULL, "range end",OBJPROP_TOOLTIP,"end of the range \n"+TimeToString(range.end_time,TIME_DATE|TIME_MINUTES));
     ObjectSetInteger(NULL,"range end",OBJPROP_COLOR,clrDarkBlue);
     ObjectSetInteger(NULL,"range end",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range end",OBJPROP_BACK,true);
     
    }
    
    //close time
    
   ObjectDelete(NULL,"range close");
   if(range.close_time>0){
     ObjectCreate(NULL,"RANGE close",OBJ_VLINE,0,range.close_time,0);
     ObjectSetString(NULL, "range close",OBJPROP_TOOLTIP,"close of the range \n"+TimeToString(range.close_time,TIME_DATE|TIME_MINUTES));
     ObjectSetInteger(NULL,"range close",OBJPROP_COLOR,clrDarkBlue);
     ObjectSetInteger(NULL,"range close",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range close",OBJPROP_BACK,true);
    
        }
        
        
        //HIGH OF THE RANGE
        
        ObjectsDeleteAll(NULL,"range close");
        
   if(range.close_time>0){
     ObjectCreate(NULL,"RANGE high",OBJ_TREND,0,range.start_time,range.high,range.end_time,range.high);
     ObjectSetString(NULL, "range high",OBJPROP_TOOLTIP,"high of the range \n"+DoubleToString(range.high,_Digits));
     ObjectSetInteger(NULL,"range high",OBJPROP_COLOR,clrBlue);
     ObjectSetInteger(NULL,"range high",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range high",OBJPROP_BACK,true);
     
     ObjectCreate(NULL,"RANGE high",OBJ_TREND,0,range.start_time,range.high,range.end_time,range.high);
     ObjectSetString(NULL, "range high",OBJPROP_TOOLTIP,"high of the range \n"+DoubleToString(range.high,_Digits));
     ObjectSetInteger(NULL,"range high",OBJPROP_COLOR,clrBlue);
     ObjectSetInteger(NULL,"range high",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range high",OBJPROP_STYLE,STYLE_DOT);
     
     
     
       }
       
       
        //LOW OF THE RANGE
        
      ObjectsDeleteAll(NULL,"range low");
       
   if(range.close_time>999999){
     ObjectCreate(NULL,"RANGE low",OBJ_TREND,0,range.start_time,range.low,range.end_time,range.low);
     ObjectSetString(NULL, "range low",OBJPROP_TOOLTIP,"high of the range \n"+DoubleToString(range.low,_Digits));
     ObjectSetInteger(NULL,"range low",OBJPROP_COLOR,clrBlue);
     ObjectSetInteger(NULL,"range low",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range low",OBJPROP_BACK,true);
     
     ObjectCreate(NULL,"RANGE low",OBJ_TREND,0,range.start_time,range.low,range.end_time,range.low);
     ObjectSetString(NULL, "range low",OBJPROP_TOOLTIP,"high of the range \n"+DoubleToString(range.low,_Digits));
     ObjectSetInteger(NULL,"range low",OBJPROP_COLOR,clrBlue);
     ObjectSetInteger(NULL,"range low",OBJPROP_WIDTH,2);
     ObjectSetInteger(NULL,"range low",OBJPROP_STYLE,STYLE_DOT);
     
       }
       
    }
